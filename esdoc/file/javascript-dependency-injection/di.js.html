<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">javascript-dependency-injection/di.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/scaljeri/javascript-dependency-injection.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/javascript-dependency-injection/di.js~DI.html">DI</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">javascript-dependency-injection/di.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">export default class DI {
    /**
     * DI makes classes accessible by a contract. Instances are created when requested and dependencies are injected into the constructor,
     * facilitating lazy initialization and loose coupling between classes.
     *
     * As an example, consider a User and Persitance classes:
     *
     *     class WebSql {
         *         constructor(name, fieldList)  { ... }
         *         persist(obj) { ... }
         *    }
     *
     *     class IndexDB {
         *         constructor(name, fieldList)  { ... }
         *         persist(obj) { ... }
         *     }
     *
     *     class User {
         *         constructor(email, passwd, storage, role) { ... }
         *         save() { this.storage.persist(this); }
         *     }
     *
     * With these classes in our pocket its time to setup the relations between them. The function that does this has the
     * following signature
     *
     *     function (&lt;contract name&gt;,
     *               &lt;class reference&gt;,
     *               [optional list of constructor arguments],
     *               {optional configuration object} )
     *
     * Or just in code:
     *
     *     var di = new DI();
     *
     *     di.register(&apos;$user&apos;, User, [null, &apos;welcome&apos;, &apos;$websql&apos;, &apos;nobody&apos;]);
     *     di.register(&apos;$websql&apos;, WebSql, [&apos;userTable&apos;, [&apos;email&apos;,&apos;passwd&apos;, &apos;role&apos;]], {singleton: true});
     *     di.register(&apos;$indexdb&apos;, IndexDB, [&apos;userTable&apos;, [&apos;email&apos;,&apos;passwd&apos;, &apos;role&apos;]], {singleton: true});
     *
     * Note that the constructor arguments are default values or contract names. Now it is easy to create
     * instances:
     *
     *     var user1 = di.getInstance(&apos;user&apos;, &apos;john@exampe.com&apos;),
     *           -&gt; email: &apos;john@exampe.com&apos;, passwd: &apos;welcome&apos;, storage : WebSQL instance, role: &apos;nobody&apos;
     *         user2 = di.getInstance(&apos;user&apos;, &apos;john@exampe.com&apos;, &apos;newSecret&apos;); // define a new password
     *           -&gt; email: &apos;john@exampe.com&apos;, passwd: &apos;newSecret&apos;, storage : WebSQL instance, role: &apos;nobody&apos;
     *
     *     if (user1 instanceof User) { ... } // user1 is an instance of User!!
     *
     * But it is also possible to use `IndexDB` as the persistance class:
     *
     *     var user = di.getInstance(&apos;user&apos;, &apos;john@exampe.com&apos;, null, &apos;indexdb&apos;), // The password is set to null too!
     *           -&gt; email: &apos;john@exampe.com&apos;, passwd: null, storage : IndexDB instance, role: &apos;nobody&apos;
     *         root = di.getInstance(&apos;user&apos;, &apos;john@exampe.com&apos;, undefined, &apos;indexdb&apos;, &apos;admin&apos;);
     *           -&gt; email: &apos;john@exampe.com&apos;, passwd: &apos;welcome&apos;, storage : IndexDB instance, role: &apos;admin&apos;
     *
     *
     * @class DI
     * @constructor
     **/
    constructor() {
        this.reset();
    }

    /**
     * Register a class by creating a contract. Use {{#crossLink &quot;DI/getInstance:method&quot;}}{{/crossLink}} to obtain
     * an instance from this contract. The &lt;tt&gt;params&lt;/tt&gt; parameter is a list of contracts,  and, if needed, normal
     * constructor parameters can be mixed in.
     *
     * @method register
     * @chainable
     * @param {String} contract name of the contract
     * @param {Class} classRef the class bind to this contract
     * @param {Array} [params] list of constructor parameters. Only if a parameter is a string and matches a contract, it
     * will be replaced with the corresponding instance
     * @param {Object} [options] configuration
     *      @param {String} [options.singleton=false] create a new instance every time
     *      @param {String} [options.factoryFor] name of the contract for which it is a factory
     *      @param {String} [options.writable=false]  append (=false) or replace (=true) construtor arguments
     * @return {Object} this
     * @example
     App.di.registerType(&quot;ajax&quot;, App.AJAX) ;
     App.di.registerType(&quot;ajax&quot;, App.AJAX, [], { singleton: true }) ;
     App.di.registerType(&quot;util&quot;, App.Util, [&quot;compress&quot;, true, [&quot;wsql&quot;, &quot;ls&quot;] ], { singleton: true } ) ;
     **/
    register(contractStr, classRef, params = [], options = {}) {
        let paramsOrigin = &apos;input&apos;;

        if (Array.isArray(classRef))
        {
            options = params;
            params = classRef;
            classRef = null;
        }
        else if (classRef &amp;&amp; typeof classRef === &apos;object&apos;)
        {
            options = classRef;
            classRef = null;
        }

        if (!Array.isArray(params)) // no params defined
        {
            options = params;
            params = [];
        }

        // --debug-start--
        if (!classRef) 
        {
            if (!options.factoryFor) 
            {
                console.warn(`#register(${contractStr}): &apos;classRef&apos; is not defined`);
            }
        }
        else if (typeof(classRef) !== &apos;function&apos;)
        {
            console.warn(`#register(${contractStr}): &apos;classRef&apos; is not a function`);
        }
        // --debug-end--


        if (params.length === 0 &amp;&amp; classRef &amp;&amp; options.autoDetect !== false)
        {
            params = params.length === 0 ? this.extractContracts(classRef) : params;
            paramsOrigin = &apos;auto&apos;;
        }

        this.contracts[contractStr] = {
            classRef: classRef,
            params: params,
            paramsOrigin: paramsOrigin,
            options: options
        };

        // Prepare factory if not manually defined
        if (!options.factoryFor &amp;&amp; !this.contracts[`${contractStr}Factory`])
        {
            this.contracts[`${contractStr}Factory`] = {
                options: {
                    factoryFor: contractStr
                    , writable: options.writable
                },
                params: []
            };
        }

        return this;
    }

    /**
     * Removes a contract
     *
     * @param {String} contractStr name of the contract
     */
    remove(contractStr) {
        delete this.contracts[contractStr];
    }

    /**
     * Removes all contracts
     */
    reset() {
        /** @private
         *  Used to check for circular dependencies
         * @type {Array}
         */
        this.depCheck = [];

        /**
         * @private
         * Used to store all the registered contracts
         * @type {{}}
         */
        this.contracts = {};
    }



    /**
     * Returns an instance for the given contract. Use &lt;tt&gt;params&lt;/tt&gt; attribute to overwrite the default
     * parameters for this contract. If &lt;tt&gt;params&lt;/tt&gt; is defined, the singleton will be (re)created and its
     * parameters are updated.
     *
     * @method getInstance
     * @param  {String} contract name
     * @param  {...*} [params] constructor parameters which, if defined, replaces its default arguments (see {{#crossLink &quot;DI/register:method&quot;}}{{/crossLink}} )
     * @return {Object} Class instance
     * @example
     App.di.register(&quot;ajax&quot;, [&quot;rest&quot;]) ;
     var ajax = App.di.getInstance(&quot;ajax&quot;) ;
     ajax = App.di.getInstance(&quot;ajax&quot;, &quot;rest&quot;, true) ;
     **/
    getInstance(contractStr, ...params) {
        let instance = null
            , contract = this.contracts[contractStr];

        if (contract)
        {
            if (contract.options.singleton)
            {
                instance = this.getSingletonInstance(contractStr, params);
            }
            else //create a new instance every time
            {
                if (contract.options.factoryFor)
                {
                    instance = this.createFactory(contractStr, params);
                }
                else
                {
                    instance = this.createInstance(contractStr, params);
                }
            }
        }

        return instance || (this.depCheck.length === 0 ? null : contractStr);
    }

    /**
     * @private
     * @param contractStr
     * @param initialParams
     * @returns {function()}
     */
    createFactory(contractStr, initialParams) {
        let contract = this.contracts[contractStr]
            , baseParams = this.mergeParams(contract, initialParams);

        return (...params) =&gt; {
            return this.getInstance(contract.options.factoryFor, ...this.mergeParams(contract, params, baseParams));
        };
    }

    /**
     * @private
     * @param contract
     * @param params
     */
    mergeParams(contract, newParams = [], initialParams = []) {
        let mergedParams = [], params;

        if (contract.paramsOrigin === &apos;auto&apos;) {
            params = contract.params.map((param) =&gt; this.contracts[param] ? param : undefined);
        } else {
            params = contract.params;
        }

        initialParams = initialParams.length === 0 ? params : initialParams;

        if (contract.options.writable)
        {
            for (let i = 0; i &lt; Math.max(newParams.length, initialParams.length); i++) {
                mergedParams.push(newParams[i] === undefined ? initialParams[i] : newParams[i]);
            }
        }
        else
        {
            mergedParams = [...initialParams, ...newParams];
        }

        return mergedParams;
    }

    /**
     * @private
     * Returns a new instance of the class matched by the contract.
     *
     * @method createInstance
     * @param {string} contract - the contract name
     * @param {Array} params - list of contracts passed to the constructor. Each parameter which is not a string or
     * an unknown contract, is passed as-is to the constructor
     *
     * @returns {Object}
     * @example
     var storage = App.di.createInstance(&quot;data&quot;, [&quot;compress&quot;, true, &quot;websql&quot;]) ;
     **/
    createInstance(contractStr, params) {
        let cr, instance
            , self = this
            , contract = this.contracts[contractStr];

        function Dependency()
        {
            cr.apply(this, self.createInstanceList(contractStr, params));
        }

        cr = contract.classRef;

        this.depCheck.push(contractStr);
        Dependency.prototype = cr.prototype;   // Fix instanceof
        instance = new Dependency();           // done
        this.depCheck.pop();

        return instance;
    }

    /** @private
     * Convert a list of contracts into a list of instances
     * A dependency list can contain arrays with dependencies too:
     *    [&quot;depA&quot;, [&quot;depB&quot;, &quot;depC&quot;], &quot;depE&quot;]
     * In this case, the constructor would, for example, look like this:
     *    function constructor(instance, array, instance) { .. }
     * */
    createInstanceList(contractStr, params) {
        let constParams = []
            , contract = this.contracts[contractStr]
            , mergedParams = this.mergeParams(contract, params);

        mergedParams.forEach((item) =&gt; {
            if (Array.isArray(item))
            {
                constParams.push(item.reduce(
                        (list, c) =&gt; {
                            list.push(this.contracts[c] ? this.getInstance(c) : c);
                            return list;
                        }, []));
            }
            else
            {
                constParams.push(this.createInstanceIfContract(item));
            }
        });

        return constParams;
    }

    /** @private
     *
     * Create or reuse a singleton instance
     */
    getSingletonInstance(contractStr, params) {
        let contract = this.contracts[contractStr]
            , mergedParams = this.mergeParams(contract, params);

        if (contract.instance === undefined || (params &amp;&amp; params.length &gt; 0))
        {
            contract.params = mergedParams;
            contract.instance = this.createInstance(contractStr);
        }

        return contract.instance;
    }

    /** @private
     *
     * @param contract
     * @returns {*}
     */
    createInstanceIfContract(contractStr) {                                     // is a contract
        let problemContract
            , constParam = contractStr;

        if (typeof(contractStr) === &apos;string&apos; &amp;&amp; this.contracts[contractStr])  // is &apos;contract&apos; just a contructor parameter or a contract?
        {
            if (this.depCheck.indexOf(contractStr) === -1)                        // check for circular dependency
            {
                constParam = this.getInstance(contractStr);                    // create the instance
                this.depCheck.pop();                                           // done, remove dependency from the list
            }
            else
            { // circular dependency detected!! --&gt; STOP, someone did something stupid -&gt; fix needed!!
                problemContract = this.depCheck[0];
                this.depCheck.length = 0;                                      // cleanup
                throw Error(&quot;Circular dependency detected for contract &quot; + problemContract);
            }
        }

        return constParam;
    }

    extractContracts(classRef) {
        let args = classRef.toString().match(/(?:(?:^function|constructor)[^\(]*\()([^\)]+)/);

        return args === null ? [] : args.slice(-1)[0].replace(/\s/g, &apos;&apos;).split(&apos;,&apos;);
    }
}


</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
